C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       12/18/2017 15:06:01 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SOFT_UART_1
OBJECT MODULE PLACED IN .\Objects\soft_uart_1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\UART\soft_uart_1.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\IIC
                    -;.\USER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USER\t
                    -ouch_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib;.\USER\UV;.\USER\ION;.\USER
                    -\EEPROM;.\USER\TM1620;.\USER\charge) DEBUG OBJECTEXTEND PRINT(.\Listings\soft_uart_1.lst) TABS(2) OBJECT(.\Objects\soft_
                    -uart_1.obj)

line level    source

   1          #include "OB39R16A6.h"
   2          #include "soft_uart.h"
   3          #include "global.h"
   4          #include "wifi_uart.h"
   5          #include "debug_uart.h"
   6          //#include "TM1618.h"
   7          /*
   8          //时钟周期 22.1184MHz
   9          1秒的机器周期为 22118400/12
  10          
  11          
  12          1ms的需要的机器周期为 22118.4/12
  13          22118.4/12 = 1843.2(0x0733)
  14          65536 - 1843 = 43418（0xF8CD）
  15          
  16          0.5ms需要的机器周期为 22118.4/12/2 = 921.6
  17          65536 - 921  = 64615(0xFC67)
  18          
  19          0.25ms需要的机器周期为 22118.4/12/2/2 = 460.8
  20          65536 - 461  = 65075(0xFE33)
  21          
  22          0.1ms需要的机器周期为 22118.4/12/10 = 184.32
  23          65536 - 184  = 65352(0xFF48)
  24          
  25          0.05ms = 50us 需要的机器周期为 22118.4/12/10/2 = 92.16
  26          65536 - 92  = 65444(0xFFA4)
  27          
  28          104.17us = 0.10417ms 需要的机器周期为 (22118.4/12)/(1/0.10417) = 192 对应的波特率 9600
  29          TMIER1采用模式2,8bit- autoreload模式 TH1 = 256 - 192 = 64 
  30          
  31          34.7us = 0.0347ms 需要的机器周期为 (22118.4/12)/(1/0.0347) = 63.96 = 64  对应的波特率为 9600*3
  32          TMIER1采用模式2,8bit- autoreload模式 TH1 = 256 - 64 = 192 
  33          */
  34          
  35          //定时器为104.17us时 U2RxRate_bk = 1；定时器为34.7s时 U2RxRate_bk = 3；
  36          static unsigned char U2RxRate_bk = 0;
  37          static unsigned char U2TxRate_bk = 0;
  38          static unsigned char U3RxRate_bk = 0;
  39          static unsigned char U3TxRate_bk = 0;
  40          
  41          #define d_T0MOD    0x20
  42          #define d_T0_TH0   192
  43          
  44          void Timer0_Init(void)
  45          {
  46   1          ET0 = 1;
  47   1          TMOD  |= d_T0MOD;
  48   1          TH0   = d_T0_TH0;  //MODE1 16bit
  49   1          //TL0   = d_T0_TL0;
  50   1          EA   = 1;
  51   1          TR0  = 1;
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       12/18/2017 15:06:01 PAGE 2   

  52   1      }
  53          
  54          void Soft_UART_Init(void)
  55          {
  56   1          Timer0_Init();
  57   1        
  58   1      #ifdef WIFI_SOFT_UART
                  U2RxRate_bk = 3;
                  U2TxRate_bk = 3;
              #endif
  62   1        
  63   1          U3RxRate_bk = 3;
  64   1          U3TxRate_bk = 3;
  65   1      }
  66          
  67          
  68          
  69          
  70          
  71          /*********************
  72          High priority interupt
  73          TIMER1  34.7us timer, 9600*3 bps
  74          中断函数内部勿使用耗时的函数，否则模拟UART的发送和接收比特率会出问题
  75          ******************/
  76          void TIMER0_ISR(void) interrupt d_T0_Vector
  77          { 
  78   1      #ifdef WIFI_SOFT_UART
                  static unsigned char U2RxBitCount = 0;
                  static unsigned char U2RxBuf = 0;
                  static unsigned char U2TxBuf = 0;
                  static unsigned char U2RxRate = 0;
              #endif
  84   1        
  85   1      //    static unsigned char U3RxBitCount = 0;
  86   1      //    static unsigned char U3RxBuf = 0;
  87   1          static unsigned char U3TxBuf = 0;
  88   1      //    static unsigned char U3RxRate = 0;
  89   1      
  90   1       /*模拟 UART2函数*/   
  91   1      #ifdef WIFI_SOFT_UART 
                // Rx
                if(U2RxPtr < U2RxBuff_MAXSIZE)
                {
                  if(U2RxBitCount)
                  {
                    if(!--U2RxRate)
                    {
                      //用两个判断 U2RxBitCount==9,此处是延时一个停止位
                      if(U2RxBitCount == 9)
                      {
                        U2RxBitCount = 0;   //stop Rxing
                        U2RxBuffer[U2RxPtr++] = U2RxBuf;
                        U2RxBuf = 0;
                        //U2RxRate = U2RxRate_bk;
                        IsU2RxBusy = 0;
                        
                      }
                      else
                      {
                        U2RxRate = U2RxRate_bk;
                        if(U2RxPin)
                        {
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       12/18/2017 15:06:01 PAGE 3   

                            U2RxBuf |= (1 << 7);
                        }
                        else
                        { 
                            U2RxBuf &= ~(1 << 7);
                        }
                        
                        U2RxBitCount++;
                        if(U2RxBitCount == 9)
                        {
                            U2RxRate = U2RxRate_bk;
                            return;
                        }
                        U2RxBuf >>= 1;          
                      }
                    }
                  }
                  else
                  {
                    if(!U2RxPin)
                    {
                      U2RxBitCount = 1;   //start Rx
                      U2RxRate = U2RxRate_bk + 1;
                      IsU2RxBusy = 1;
                    }
                  }  
                }
              
                
                
                //to initiate a Tx, just write the U8 data to U2TxBuf,and set U2TxBitCount = 10 ,U2TxRate set to 3
                //first check if it's Txing (if U2TxBitCount != 0), 
              
                
                if(U2TxBitCount){
                  if(!--U2TxRate){
                    U2TxRate = U2TxRate_bk;
                    //
                    switch(U2TxBitCount --){
                      case 1:   //Stop bit; send next byte
                        U2TxPin = 1;
                        if(U2TxPtr != U2LdPtr){
                          U2TxBuf = U2TxBuffer[U2TxPtr ++];
                          U2TxBitCount = 10;
                        }
                        else{
                          U2TxPtr = 0;
                          U2LdPtr = 0;
                          IsU2TxBusy = 0;
                        }
                      break;
              
                      case 10:  //Start bit
                        IsU2TxBusy = 1;
                        U2TxPin = 0;
                        if(U2TxPtr == 0)
                        {
                          U2TxBuf = U2TxBuffer[U2TxPtr ++];
                        }
                      break;
                      
                      default:
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       12/18/2017 15:06:01 PAGE 4   

                        //U2TxPin = U2TxBuf & 0XFE;
                        U2TxPin = U2TxBuf & 0x01;
                        U2TxBuf >>= 1;
                      break;
              
                    }
                  }
                } 
               #endif
 185   1        
 186   1      
 187   1      /*模拟 UART3函数*/  
 188   1        // Rx
 189   1      /*
 190   1        if(U3RxPtr < U3RxBuff_MAXSIZE)
 191   1        {
 192   1          if(U3RxBitCount)
 193   1          {
 194   1            if(!--U3RxRate)
 195   1            {
 196   1              //用两个判断 U2RxBitCount==9,此处是延时一个停止位
 197   1              if(U3RxBitCount == 9)
 198   1              {
 199   1                U3RxBitCount = 0;   //stop Rxing
 200   1                U3RxBuffer[U3RxPtr++] = U3RxBuf;
 201   1                U3RxBuf = 0;
 202   1                IsU3RxBusy = 0;
 203   1                
 204   1              }
 205   1              else
 206   1              {
 207   1                U3RxRate = U3RxRate_bk;
 208   1                if(U3RxPin)
 209   1                {
 210   1                    U3RxBuf |= (1 << 7);
 211   1                }
 212   1                else
 213   1                { 
 214   1                    U3RxBuf &= ~(1 << 7);
 215   1                }
 216   1                
 217   1                U3RxBitCount++;
 218   1                if(U3RxBitCount == 9)
 219   1                {
 220   1                    return;
 221   1                }
 222   1                U3RxBuf >>= 1;          
 223   1              }
 224   1            }
 225   1          }
 226   1          else
 227   1          {
 228   1            if(!U3RxPin)
 229   1            {
 230   1              U3RxBitCount = 1;   //start Rx
 231   1              U3RxRate = U3RxRate_bk + 1;
 232   1              IsU3RxBusy = 1;
 233   1            }
 234   1          }  
 235   1        }
 236   1      */
 237   1        
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       12/18/2017 15:06:01 PAGE 5   

 238   1       
 239   1        
 240   1        //to initiate a Tx, just write the U8 data to U2TxBuf,and set U2TxBitCount = 10 ,U2TxRate set to 3
 241   1        //first check if it's Txing (if U2TxBitCount != 0), 
 242   1      
 243   1        
 244   1        if(U3TxBitCount){
 245   2          if(!--U3TxRate){
 246   3            U3TxRate = U3TxRate_bk;
 247   3            //
 248   3            switch(U3TxBitCount --){
 249   4              case 1:   //Stop bit; send next byte
 250   4                U3TxPin = 1;
 251   4                if(U3TxPtr != U3LdPtr){
 252   5                  U3TxBuf = U3TxBuffer[U3TxPtr ++];
 253   5                  U3TxBitCount = 10;
 254   5                }
 255   4                else{
 256   5                  U3TxPtr = 0;
 257   5                  U3LdPtr = 0;
 258   5                  IsU3TxBusy = 0;
 259   5                }
 260   4              break;
 261   4      
 262   4              case 10:  //Start bit
 263   4                IsU3TxBusy = 1;
 264   4                U3TxPin = 0;
 265   4                if(U3TxPtr == 0)
 266   4                {
 267   5                  U3TxBuf = U3TxBuffer[U3TxPtr ++];
 268   5                }
 269   4              break;
 270   4              
 271   4              default:
 272   4                U3TxPin = U3TxBuf & 0x01;
 273   4                U3TxBuf >>= 1;
 274   4              break;
 275   4      
 276   4            }
 277   3          }
 278   2        }   
 279   1        
 280   1        
 281   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    189    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
