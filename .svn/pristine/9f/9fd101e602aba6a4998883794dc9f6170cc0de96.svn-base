C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SYS_RUN
OBJECT MODULE PLACED IN .\Objects\sys_run.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\SYS_RUN\sys_run.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\IIC;
                    -.\USER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USER\to
                    -uch_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib;.\USER\UV;.\USER\ION;.\USER\
                    -EEPROM;.\USER\TM1620;.\USER\charge) DEBUG OBJECTEXTEND PRINT(.\Listings\sys_run.lst) TABS(2) OBJECT(.\Objects\sys_run.ob
                    -j)

line level    source

   1          #include <stdio.h>
   2          #include "global.h"
   3          #include "sys_run.h"
   4          #include "dc_motor.h"
   5          #include "step_motor.h"
   6          //#include "TM1618.h"
   7          #include "sensor.h"
   8          #include "buzzer.h"
   9          #include "UV.h"
  10          #include "wifi_uart.h"
  11          #include "common.h"
  12          #include "ION.h"
  13          #include "debug_uart.h"
  14          #include "TM1620.h"
  15          #include "timer.h"
  16          
  17          
  18          
  19          void sys_data_clear(void)
  20          {
  21   1      
  22   1      }
  23          
  24          //∑¿÷π≤÷√≈ªµ¡À£¨ø™ª˙ ±±ÿ–ÎΩ¯––≤÷√≈ºÏ≤‚°£»Áπ˚≤÷√≈ªµ¡À‘Ÿ¥Úø™∑Áª˙ø…ƒ‹ª·…’ªµ∑Áª˙
  25          void sys_init_check(void)
  26          {
  27   1          unsigned char delay_1s_times = 0;
  28   1          
  29   1          if(sys_mode == STANDBY && IsStepMotorBusy == 0)
  30   1          {
  31   2              if(!DOOR_CHECK_PIN)
  32   2              {
  33   3                  IsSysFault = 1;
  34   3              }
  35   2          }  
  36   1        
  37   1          if(IsSysFault)
  38   1          {
  39   2              Door_Close();
  40   2          }
  41   1          else
  42   1          {
  43   2              return;
  44   2          }
  45   1          while(delay_1s_times < 10)
  46   1          {
  47   2              if(_test_timeflag(g_2ms_flag))
  48   2              {
  49   3                  g_2ms_flag = 0;
  50   3                  TurnMotor();           
  51   3              } 
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 2   

  52   2            
  53   2              if(_test_timeflag(g_1s_flag))
  54   2              {
  55   3                  g_1s_flag = 0;
  56   3                  delay_1s_times += 1;
  57   3                  if(beats == 0 && DOOR_CHECK_PIN == 1)
  58   3                  {
  59   4                      IsSysFault = 0;
  60   4                      return;
  61   4                  }           
  62   3              }
  63   2          }
  64   1      }
  65          
  66          
  67          
  68          void sys_start(void)
  69          {
  70   1          sys_start_time = get_sys_stime();
  71   1          //PM25_value_bak = PM25_value;
  72   1          UV_On();
  73   1          ION_On();
  74   1          Buzzer_Power_On();  
  75   1        
  76   1          //ø™∆ÙUVµ∆∫Û—” ±“ª∂Œ ±º‰£¨≤ª»√À˘”–…Ë±∏Õ¨ ±∆Ù∂Ø  
  77   1          while(get_sys_stime() < (sys_start_time + 1)) ;
  78   1      
  79   1          if(Is_Door_Open == 0 || (Is_Door_Open == 1 && DOOR_CHECK_PIN == 1))
  80   1          {
  81   2            Door_Open();
  82   2          }
  83   1          Start_DC_Motor();
  84   1          
  85   1          
  86   1          sys_mode = RUNNING;
  87   1          IsFanRunning = 1;
  88   1          IsSpeedChanged = 1;
  89   1          TM1820_LED_Control(LED_SLEEP_MODE,LED_OFF);
  90   1          TM1820_LED_Control(LED_SPEED_LOW,LED_ON);
  91   1      }
  92          
  93          void sys_stop(void)
  94          {
  95   1          sys_stop_time = get_sys_stime();
  96   1          //PM25_value_bak = PM25_value;
  97   1          Buzzer_Power_Off();
  98   1          sys_mode = STANDBY;
  99   1          Stop_DC_Motor();
 100   1          Door_Close();
 101   1          UV_Off();
 102   1          ION_Off();
 103   1          sys_data_clear();   
 104   1          IsSpeedChanged = 1;
 105   1          Is_Door_Open = 0;
 106   1          run_mode = 0;
 107   1          TM1820_LED_Control(LED_ALL,LED_OFF);
 108   1          TM1820_LED_Control(LED_SLEEP_MODE,LED_ON);
 109   1        
 110   1          IsUVfault = 0;
 111   1      }
 112          
 113          
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 3   

 114          void sys_run(void)
 115          {
 116   1      //    unsigned char wifi_count_times = 0;
 117   1      //    unsigned long nowtimes = 0;
 118   1          unsigned char debug_buff[30] = {0};
 119   1          
 120   1          //wifi≈‰Õ¯”¿‘∂”––ß,wifi≈‰Õ¯–Ë◊È∫œ∞¥º¸≥÷–¯∞¥œ¬≥¨π˝2√Î≤≈Ω¯»Î≈‰Õ¯ƒ£ Ω£¨∑¿÷πŒÛ≤Ÿ◊˜
 121   1          if(key_info.IsTouchedKey == 1 && key_info.WhichKey == KEY_WIFI)
 122   1          {
 123   2              wifi_easylink_cmd();
 124   2              Clear_Touch_Info();
 125   2          }
 126   1          
 127   1          //»Áπ˚”–»À∞—≤÷√≈πÿ±’¡À£¨‘Úª˙∆˜Ω¯»Î¥˝ª˙◊¥Ã¨
 128   1          check_if_doorclose_manual();
 129   1          
 130   1          
 131   1          if(cost_info.IsCostType == 1 && cost_info.IsHavetime == 1 && cost_info.IsChargeStart == 1)
 132   1          {
 133   2      //        sprintf(debug_buff,"step1");
 134   2      //        DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));
 135   2              if(IsSysFault == 1)
 136   2              {
 137   3                  return;
 138   3              }
 139   2              if(sys_mode == STANDBY)
 140   2              {
 141   3                  mymemset(debug_buff,0,mystrlen(debug_buff));
 142   3                  sprintf(debug_buff,"step2\n");
 143   3                  DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));
 144   3                
 145   3                  sys_start();  
 146   3                  cost_info.IsChargeStart = 0;
 147   3                  //«Â≥˝∞¥º¸–≈œ¢£¨∑¿÷π‘⁄ø™∆Ù…Ë±∏«∞∂‘∞¥º¸”–≤Ÿ◊˜£¨∑Ò‘Úµ±¥Úø™…Ë±∏ ±£¨÷Æ«∞±£¡Ùµƒ∞¥º¸≤Ÿ◊˜ª·¬Ì…œ÷¥––
 148   3                  Clear_Touch_Info();
 149   3              }
 150   2              
 151   2          }
 152   1        
 153   1          //»Áπ˚ «º∆∑—ƒ£ Ω£¨∂¯«“√ª”– ±º‰¡À£¨‘Ú∞¥º¸ ß–ß
 154   1          if(cost_info.IsCostType == 1 && cost_info.IsHavetime == 0)
 155   1          {
 156   2              if(sys_mode == RUNNING)
 157   2              {
 158   3                  mymemset(debug_buff,0,mystrlen(debug_buff));
 159   3                  sprintf(debug_buff,"step3\n");
 160   3                  DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));
 161   3                  sys_stop();  
 162   3                  
 163   3      
 164   3              }
 165   2              return;
 166   2          }
 167   1        
 168   1        
 169   1          if(key_info.IsTouchedKey == 1)
 170   1          {
 171   2              switch(key_info.WhichKey)
 172   2              {
 173   3                case KEY_POWER:
 174   3                  if(sys_mode == STANDBY)
 175   3                  {
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 4   

 176   4                      sys_start();             
 177   4                  }
 178   3                  else if(sys_mode == RUNNING)
 179   3                  { 
 180   4                      sys_stop();              
 181   4                  }
 182   3                  break;
 183   3                case KEY_SPEED:
 184   3                  if(sys_mode == RUNNING)
 185   3                  {
 186   4                      Buzzer_Speed();
 187   4                      if(speed_dang < HIGH_SPEED )
 188   4                      {
 189   5                          speed_dang++;
 190   5                          IsSpeedChanged = 1;
 191   5                      }
 192   4                      else if(speed_dang == HIGH_SPEED)
 193   4                      {
 194   5                          speed_dang = QUIET_SPEED;
 195   5                          IsSpeedChanged = 1;
 196   5                      }
 197   4                      else
 198   4                      {
 199   5                          break;
 200   5                      }
 201   4                      TM1820_LED_Control(speed_dang + 1,LED_ON);
 202   4                      
 203   4                      //‘⁄◊‘∂Øƒ£ Ωœ¬£¨»Áπ˚ ÷∂Øµ˜Ω⁄∑Á¡ø¡À£¨‘Ú»°œ˚◊‘∂Øƒ£ Ω
 204   4                      run_mode = 0;
 205   4                  }
 206   3                  else
 207   3                  {
 208   4                      break;
 209   4                  }
 210   3                  break;
 211   3                case KEY_TIMER:
 212   3                  if(sys_mode == RUNNING)
 213   3                  {
 214   4      
 215   4                  }
 216   3                  else
 217   3                  {
 218   4                      break;
 219   4                  }            
 220   3                  
 221   3                  break;
 222   3                case KEY_MODE:
 223   3                  if(sys_mode == RUNNING)
 224   3                  {
 225   4      
 226   4                  }
 227   3                  else
 228   3                  {
 229   4                      break;
 230   4                  }           
 231   3                  break;
 232   3                case KEY_WIFI:
 233   3                  //control wifi to easylink mode          
 234   3                  break;            
 235   3                  
 236   3                  
 237   3                default:
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 5   

 238   3                  break;
 239   3                  
 240   3              
 241   3              }
 242   2              if(key_info.IsTouchedKey == 1 && key_info.WhichKey != KEY_WIFI)
 243   2              {
 244   3                  Clear_Touch_Info();
 245   3              }
 246   2              
 247   2          }
 248   1          
 249   1          if(run_mode == 1)
 250   1          {
 251   2              sys_smart_mode();
 252   2          }
 253   1      
 254   1      }
 255          
 256          //µ±≤÷√≈πÿ±’ ±£¨≤÷√≈ºÏ≤‚“˝Ω≈ «∏ﬂµÁ∆Ω£ªµ±≤÷√≈¥Úø™ ±£¨≤÷√≈ºÏ≤‚“˝Ω≈ «µÕµÁ∆Ω
 257          void sys_selfcheck(void)
 258          {
 259   1          Is_selfcheck = 1;
 260   1          if(DOOR_CHECK_PIN == 0 )
 261   1          {
 262   2          
 263   2          }
 264   1          
 265   1      }
 266          
 267          
 268          #define GET_SENSOR_TIME_INTERVAL    (2)
 269          #define RUN_CONTINUE_TIME    (1*60)
 270          #define STOP_CONTINUE_TIME   (10*60)   //10min
 271          #define STANDBY_UPDATA_DATA_INTERVAL  (15*60)   //15min
 272          //#define RUN_CONTINUE_TIME    (1*60)
 273          //#define STOP_CONTINUE_TIME   (1*60)   //10min
 274          //#define STANDBY_UPDATA_DATA_INTERVAL  (1*60)   //15min
 275          
 276          void display_pm_data(void)
 277          {
 278   1          static bit change_to_3min_updata = 0;
 279   1          static bit IsPowerOn = 0;
 280   1          static unsigned long get_pm_trigger_time = 0;
 281   1          static unsigned long standby_trigger_time = 0;
 282   1          static unsigned int temp_pm_value = 0;
 283   1          unsigned long nowtime = 0;
 284   1       
 285   1          //unsigned char pm_adjust = 0;
 286   1          //const unsigned int get_sensor_data_time_interval = 5 * 1000;
 287   1        
 288   1      //    unsigned char debug_buff[30] = {0};
 289   1          
 290   1          //unsigned long temp = 0;
 291   1      //    unsigned long temp_low,temp_high = 0;
 292   1      //    unsigned long temp_1 = 0;
 293   1        
 294   1        
 295   1          //get_sensor_data_time_interval = GET_SENSOR_TIME_INTERVAL;
 296   1        
 297   1          nowtime = get_sys_stime();
 298   1          
 299   1          if(nowtime <= GET_SENSOR_TIME_INTERVAL && get_pm_trigger_time >= (0xFFFFFFFF - GET_SENSOR_TIME_INTERVA
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 6   

             -L))
 300   1          {
 301   2              get_pm_trigger_time = nowtime + GET_SENSOR_TIME_INTERVAL;
 302   2          }
 303   1          
 304   1          // ÷‹∆⁄–‘ªÒ»°¥´∏–∆˜ ˝æ›£¨ ±º‰º‰∏Ù GET_SENSOR_TIME_INTERVAL £¨µ•Œªs
 305   1          if(nowtime >= get_pm_trigger_time)
 306   1          {
 307   2              PM25_value = Read_PMSensor_Data();
 308   2              //get_pm_trigger_time = nowtime + get_sensor_data_time_interval;
 309   2              get_pm_trigger_time = nowtime + (GET_SENSOR_TIME_INTERVAL | 0x00);
 310   2              
 311   2            
 312   2              //5√Î÷”∏¸–¬“ª¥Œ ˝¬Îπ‹œ‘ æµƒ ˝æ›
 313   2              TM1620_DispalyData(SENSOR_PM25,display_pm_value);
 314   2      
 315   2          }
 316   1          if(sys_mode == RUNNING)
 317   1          {
 318   2              if(IsPowerOn == 0)
 319   2              {
 320   3                  IsPowerOn = 1;
 321   3              }
 322   2              if(change_to_3min_updata == 1)
 323   2              {
 324   3                  change_to_3min_updata = 0;
 325   3              }
 326   2              
 327   2              if(nowtime <= (sys_start_time + (RUN_CONTINUE_TIME | 0x00)))
 328   2              {
 329   3                  //¥Úø™…Ë±∏∫Ûµƒ 60 √Îƒ⁄œ‘ æø™ª˙«∞µƒ ˝÷µ
 330   3                  if(nowtime <= 180)
 331   3                  {
 332   4                      //…Ë±∏∏’…œµÁ£¨¥À ±œ‘ æ µ ± ˝÷µ
 333   4                      if(PM25_value_bak < PM25_value)
 334   4                      {
 335   5                          display_pm_value = (unsigned int)PM25_value;
 336   5                          PM25_value_bak = (unsigned int)PM25_value;
 337   5                      }
 338   4                      else
 339   4                      {
 340   5                          display_pm_value = PM25_value_bak;
 341   5                      }
 342   4      
 343   4                    
 344   4      //               mymemset(debug_buff,0,30);
 345   4      //               sprintf(debug_buff,"step1\n");
 346   4      //               DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));
 347   4                  }
 348   3                  else
 349   3                  {
 350   4                      //¥À÷÷«Èøˆ «…Ë±∏“—æ≠…œµÁ“ª∂Œ ±º‰£¨¥”¥˝ª˙Ω¯»Î‘À––ƒ£ Ω£¨Œ™¡À∑¿÷πœ‘ æµƒ ˝÷µ…œ’«£¨œ‘ æ¥˝ª˙ ±µƒ
             - ˝÷µ
 351   4                      display_pm_value = (unsigned int)PM25_value_bak;
 352   4                    
 353   4                    
 354   4      //               mymemset(debug_buff,0,30);
 355   4      //               sprintf(debug_buff,"step2\n");
 356   4      //               DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));              
 357   4                    
 358   4                  }
 359   3      
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 7   

 360   3              }
 361   2              else
 362   2              {
 363   3                  //»°¡Ω¥ŒªÒ»°µΩµƒ ˝æ›µƒ∆Ωæ˘÷µ£¨∑¿÷π ˝æ›Ã¯±‰π˝øÏ
 364   3                  display_pm_value = ((unsigned int)PM25_value + PM25_value_bak) / 2;
 365   3                  PM25_value_bak = (unsigned int)PM25_value;
 366   3              }
 367   2      
 368   2          }
 369   1          else if(sys_mode == STANDBY)
 370   1          {
 371   2              
 372   2              //œµÕ≥¥˝ª˙∫Û£¨’˝≥£«Èøˆœ¬PM2.5 ˝æ›ª·œ¬Ωµ£¨¥À¥¶ ˝æ›Ω¯––¥¶¿Ì£¨¥˝ª˙∫Û10∑÷÷”ƒ⁄»Áπ˚ ˝æ›œ¬Ωµ‘Úœ‘ æ∏’¥˝ª˙ 
             -±µƒ ˝æ›
 373   2              if(IsPowerOn == 0)
 374   2              {
 375   3                  //∏’ø™ª˙«∞3∑÷÷”ƒ⁄œ‘ æ µ ± ˝æ›
 376   3                  if(nowtime < (STANDBY_UPDATA_DATA_INTERVAL | 0x00))
 377   3                  {
 378   4                      if(PM25_value_bak < (unsigned int)PM25_value)
 379   4                      {
 380   5                          PM25_value_bak = (unsigned int)PM25_value;
 381   5                      }
 382   4                      display_pm_value = PM25_value_bak; 
 383   4                      goto exit;              
 384   4                  }
 385   3                  else
 386   3                  {
 387   4                      IsPowerOn = 1;
 388   4                      change_to_3min_updata = 1;
 389   4                      temp_pm_value = 0;
 390   4                      standby_trigger_time = nowtime + (STANDBY_UPDATA_DATA_INTERVAL | 0x00);
 391   4                  }
 392   3              }
 393   2              else
 394   2              {
 395   3                  if(change_to_3min_updata == 0)
 396   3                  {
 397   4                      if(nowtime < (sys_stop_time + (STOP_CONTINUE_TIME | 0x00)))
 398   4                      {
 399   5                          //¥”‘À––ƒ£ ΩΩ¯»Î¥˝ª˙∫Ûµƒ10minƒ⁄£¨PMµƒ ˝æ›≤ªƒ‹–°”⁄∏’Ω¯»Î¥˝ª˙ƒ£ Ω ±µƒ ˝æ›
 400   5                          if(PM25_value < PM25_value_bak)
 401   5                          {
 402   6                              //»°∆Ωæ˘÷µ «Œ™¡À∑¿÷πœ‘ æ ˝æ›±‰ªØ¥Û
 403   6                              display_pm_value = (PM25_value_bak + display_pm_value) / 2;
 404   6                          }
 405   5                          else
 406   5                          {
 407   6                              //∑¿÷π∏’Ω¯»Î¥˝ª˙ ± ˝æ›±‰ªØ∑∂ŒßÃ´¥Û
 408   6                              display_pm_value = ((unsigned int)PM25_value + display_pm_value + PM25_value_bak) 
             -/ 3;
 409   6                          }                        
 410   5                      } 
 411   4                      else
 412   4                      {
 413   5                          change_to_3min_updata = 1; 
 414   5                          temp_pm_value = 0;
 415   5                          standby_trigger_time = nowtime + (STANDBY_UPDATA_DATA_INTERVAL | 0x00);
 416   5                      }                  
 417   4                  }
 418   3                  else
 419   3                  {
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 8   

 420   4                      //ªÒ»° STANDBY_UPDATA_DATA_INTERVAL  ∑÷÷”ƒ⁄◊Ó¥Ûµƒ ˝æ›£¨”√”⁄œ‘ æ
 421   4                      if(temp_pm_value <= (unsigned int)PM25_value)
 422   4                      {
 423   5                          temp_pm_value = (unsigned int)PM25_value;
 424   5      
 425   5                      }
 426   4                      
 427   4                      if(PM25_value_bak < (unsigned int)PM25_value)
 428   4                      {
 429   5                          PM25_value_bak = (unsigned int)PM25_value;
 430   5                          display_pm_value = ((unsigned int)PM25_value + display_pm_value) / 2;
 431   5                              
 432   5                      }               
 433   4                  
 434   4                      if(nowtime >= standby_trigger_time)
 435   4                      {
 436   5                          //…œ¥Œœ‘ æµƒ ˝æ›∫Õ’‚¥ŒªÒ»°µΩµƒ◊Ó¥Û÷µ«Û∫Õ£¨»ª∫Û»°∆Ωæ˘÷µ£¨≤ª»ªø…ƒ‹ª·µº÷¬2¥Œœ‘ æµƒ ˝æ›Ã¯±
             -‰±»Ωœ¥Û
 437   5                          display_pm_value = (temp_pm_value + PM25_value_bak) / 2;
 438   5                          PM25_value_bak = display_pm_value;
 439   5                          temp_pm_value = 0;
 440   5                           
 441   5                          standby_trigger_time += (STANDBY_UPDATA_DATA_INTERVAL | 0x00);
 442   5                        
 443   5                        
 444   5      //                    temp_low = standby_trigger_time & 0xFFFF;     
 445   5      //                    temp_high = (standby_trigger_time >> 16) & 0xFFFF;   
 446   5      //                    mymemset(debug_buff,0,30);
 447   5      //                    sprintf(debug_buff,"trigger time:0x%x%4x\n",(unsigned int)temp_high,(unsigned int)te
             -mp_low);
 448   5      //                    DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));  
 449   5                      } 
 450   4                    
 451   4                  }
 452   3            
 453   3              }
 454   2              
 455   2          }
 456   1          
 457   1       exit:
 458   1          
 459   1          return;
 460   1          
 461   1          
 462   1      }
 463          
 464          
 465          
 466          //‘⁄◊‘∂Øƒ£ Ωœ¬£¨∑Áª˙µµŒª«–ªª∫Û10√Î÷”ƒ⁄≤ª‘ –Ì‘Ÿ¥Œ«–ªª£¨∑Ò‘ÚPM‘⁄¡ŸΩÁ÷µ ±ª·∑«≥£∆µ∑±µƒ«–ªªµµŒª£¨ÃÂ—È≤ª∫√
 467          void sys_smart_mode(void)
 468          {
 469   1          
 470   1          static bit speed_changed = 0;   //∑¿÷πPM≈®∂»‘⁄¡ŸΩÁ÷µ ±£¨∆µ∑±«–ªªµµŒª
 471   1          static bit IsLedChange = 0;
 472   1          static unsigned long speed_changed_time = 0;   //…œ¥Œ«–ªª∑Áµ≤ ±µƒ ±º‰
 473   1        
 474   1          const unsigned char speed_continue_time = 10;  //10√Î÷”ƒ⁄≤ªƒ‹‘Ÿ¥Œ«–ªª∑Áµ≤
 475   1        
 476   1          unsigned long nowtime = 0;
 477   1        
 478   1          
 479   1        
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 9   

 480   1          if((cost_info.IsCostType == 1 && cost_info.IsHavetime == 0) || sys_mode == STANDBY)
 481   1          {
 482   2              return;
 483   2          }
 484   1          
 485   1          nowtime = get_sys_stime();
 486   1          
 487   1          if(speed_changed == 1)
 488   1          {
 489   2              //∑Áª˙µµŒª∏’«–ªªπ˝£¨10√Î“‘∫Û≤≈ƒ‹«–ªª
 490   2              if(nowtime <= (speed_changed_time + speed_continue_time))
 491   2              {
 492   3                  return;
 493   3              }
 494   2              else
 495   2              {
 496   3                  speed_changed = 0;
 497   3              }
 498   2              
 499   2          }
 500   1          
 501   1          if(display_pm_value < PM25_QUIET_SPEED )
 502   1          {
 503   2              if(speed_dang != QUIET_SPEED)
 504   2              {
 505   3                  speed_dang = QUIET_SPEED;
 506   3                  IsSpeedChanged = 1;
 507   3                  speed_changed = 1;
 508   3                  IsLedChange = 1;
 509   3              }       
 510   2          }
 511   1          else if(display_pm_value < PM25_LOW_SPEED)
 512   1          {
 513   2              if(speed_dang != LOW_SPEED)
 514   2              {
 515   3                  speed_dang = LOW_SPEED;
 516   3                  IsSpeedChanged = 1;
 517   3                  speed_changed = 1;
 518   3                  IsLedChange = 1;
 519   3              }  
 520   2          }
 521   1          else
 522   1          {
 523   2              if(speed_dang != HIGH_SPEED)
 524   2              {
 525   3                  speed_dang = HIGH_SPEED;
 526   3                  IsSpeedChanged = 1;
 527   3                  speed_changed = 1;
 528   3                  IsLedChange = 1;
 529   3              }
 530   2          }   
 531   1      
 532   1          if(IsLedChange == 1)
 533   1          {
 534   2              //◊‘∂Øƒ£ Ωœ¬£¨∑Áµ≤±‰∫Û£¨LEDµ∆“≤“™œ‡”¶µƒ±‰ªØ
 535   2              TM1820_LED_Control(speed_dang + 1,LED_ON);
 536   2              IsLedChange = 0;       
 537   2          }      
 538   1      
 539   1      }
 540          
 541          
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 10  

 542          
 543          
 544          //œµÕ≥◊‘ºÏ
 545          void sys_dev_selfcheck(void)
 546          {
 547   1      
 548   1      
 549   1      }
 550          
 551          
 552          
 553          //œµÕ≥‘À–– ±£¨»Áπ˚”–»À ÷∂Ø∞—≤÷√≈πÿ±’¡À£¨‘Úª˙∆˜Ω¯»Î¥˝ª˙ƒ£ Ω
 554          //ºÏ≤‚∑Ω∑®£∫100msºÏ≤‚“ª¥Œ≤÷√≈£¨»Áπ˚¡¨–¯2√Î÷”≤÷√≈∂º «πÿ±’µƒ£¨‘Úª˙∆˜Ω¯»Î¥˝ª˙ƒ£ Ω
 555          #define MAX_DOOR_CLOSE_TIMES    20
 556          void check_if_doorclose_manual(void)
 557          {
 558   1          static unsigned char check_doorclose_times = 0;
 559   1          unsigned long nowtime = 0;
 560   1          
 561   1        
 562   1          if(sys_mode == RUNNING)
 563   1          {
 564   2              nowtime = get_sys_stime();
 565   2              if(nowtime >= (sys_start_time + 10))
 566   2              {
 567   3                  if(g_100ms_flag == 1)
 568   3                  {
 569   4                      if(DOOR_CHECK_PIN == 1)
 570   4                      {
 571   5                          check_doorclose_times += 1;
 572   5                      }
 573   4                      else
 574   4                      {
 575   5                          check_doorclose_times = 0;
 576   5                      }
 577   4                      
 578   4                      if(check_doorclose_times >= MAX_DOOR_CLOSE_TIMES)
 579   4                      {
 580   5                          if(sys_mode == RUNNING)
 581   5                          {
 582   6                              sys_stop();
 583   6                              check_doorclose_times = 0;
 584   6                          }
 585   5      
 586   5                      }
 587   4                  }
 588   3              }
 589   2          }
 590   1      
 591   1      }
 592          
 593          
 594          
 595          
 596          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2027    ----
   CONSTANT SIZE    =     44    ----
   XDATA SIZE       =     15      44
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.52.0.0   SYS_RUN                                                           11/01/2017 16:12:32 PAGE 11  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
